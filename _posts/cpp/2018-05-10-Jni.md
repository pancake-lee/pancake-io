---
title: 'JNI的基本使用'
description: 'JAVA与C/C++沟通的桥梁'
author: Pancake
date: 2018-05-10
categories: Coding
tags: Java Cpp
---

* 各种理论，jni和jna对比等，请自行百度，这里仅介绍一下基本使用方法，方便初学者，也给自己留一份笔记而已。
* 介绍jni的使用流程
* 示例了java中string和byte[]与c++的类型转换，以及容易忽略的内存泄漏问题
* 简单介绍了native方法定义为static的相关问题

# 使用流程
简单说一下jni的使用流程就像一个圆，从java出发，声明你需要的native方法，生成一个对应的.h文件，根据这个h文件构造c/c++工程生成dll/so动态库，最后返回来给java调用。
## 1 : java class
src/jni/LibTest.java:  

```cpp
public class LibTest {
    static {
        System.loadLibrary("jni_lib_LibTest");
    }

    public native static void HelloWorld(String i_instr);
}
```

src/JniTest.java:  

```cpp
public class JniTest {
    public static void main(String[] args) {
        LibTest.HelloWorld(new String("I'm Pancake"));
    }
}
``` 

到这里java的代码可以说是全部写完了，当main方法执行时，将调用LibTest的HelloWorld方法，该方法的实现来自于jni_lib_LibTest.dll(libjni_lib_LibTest.so)中，那么这个工程现在缺少的就是这个c++动态库了，下面来生成这个动态库。

 

## 2 : dll/so

无论是windows还是linux，你需要确保命令行可以运行javac，不行的自行百度安装jdk并且设置环境变量。
* 在定义native的.java文件目录下用javac编译该文件获得.class文件。  
cd src/jni/  
javac LibTest.java

* 然后前往该项目的源码目录，用javah处理刚才生成的.class文件，这里javah后面跟的不是路径，而是java中的包名+类名(注意一下命令与文件路径(src/jni/LibTest.java)的关系)  
cd src/  
javah jni.LibTest

* 生成了一个.h文件，该文件官方说法是建议不要修改的，然后根据这个.h文件构建一个c/c++工程生成对应的动态库。  
jni_lib_LibTest.h：  

```cpp
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class jni_lib_LibTest */

#ifndef _Included_jni_lib_LibTest
#define _Included_jni_lib_LibTest
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     jni_lib_LibTest
 * Method:    HelloWorld
 * Signature: (Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_jni_1lib_LibTest_HelloWorld
  (JNIEnv *, jclass, jstring);

#ifdef __cplusplus
}
#endif
#endif
```

* 编写对应c/cpp文件，jni_lib_LibTest.cpp：  

```cpp
#include "jni_lib_LibTest.h"
#include <iostream>
using namespace std;

JNIEXPORT void JNICALL Java_jni_1lib_LibTest_HelloWorld
(JNIEnv *env, jclass, jstring j_i_inStr) {
    char* i_inStr = (char*)env->GetStringUTFChars(j_i_inStr, false);
    if (i_inStr == NULL) {
        cout << "i_inStr == NULl!" << endl;
        return ;
    }
    cout << "OutPut in jni_lib_LibTest.cpp!" << endl;
    cout << "Helloworld! i_inStr is : " << i_inStr << endl;
    env->ReleaseStringUTFChars(j_i_inStr, i_inStr);
}
```
* 编译成动态库  
某些系统会出现找不到jni.h和jni_md.h你需要把路径加入编译选项  
视情况加入：-I $(JAVA_HOME)/include/     
视情况加入：-I $(JAVA_HOME)/include/linux（jni_md.h一般再include子目录下找一下就能找到了）  
g++ -shared -o libjni_lib_LibTest.so jni_lib_LibTest.cpp

## 3 : java加载jni_lib_LibTest.dll / libjni_lib_LibTest.so
* 把这个.dll(.so)动态库放到合适的地方，可以是系统默认库目录，也可以通过设置LD_LIBRARY_PATH的值实现，更多关于找不到库的问题需要视乎不同系统，不同平台，不同ide区分解决办法，这里不详细描述  
System.loadLibrary("jni_lib_LibTest"); //注意文件名与库名的对应规则
* 同样你也可以使用绝对路径来加载：如  
System.load("/home/Pancake/libjni_lib_LibTest.so");
* 运行java程序，输出如下：  

```cpp
OutPut in jni_lib_LibTest.cpp!
Helloworld! i_inStr is : I'm Pancake
```
# 介绍两个常用的类型转换
关于jni的内存管理，在这里不做详细描述，提供几个关键词进行搜索：  
Heap Memory/Native Memory/LocalReference/GlobalReference/Weak Global Reference  
目前个人简单理解是：除了使用JNIEnv方法创建的，然后return给java的对象以外，其他的都需要进行内存的释放，最基础的使用是java层入参，如：GetStringUTFChars把jstring类型转换成char*后，务必使用ReleaseStringUTFChars进行释放  
* string获取:  
获取传入参数String：jstring java_string

```cpp
char* str_cpp =(char*)(env->GetStringUTFChars(java_string, false)); 
if(str_cpp == NULL) { 
    return NULL;
}
//do something
env->ReleaseStringUTFChars(java_string, str_cpp);
```
* srting返回：  

```cpp
char* str = "Pancake";
//do something
return env->NewStringUTF(str);  
```
* byte[]获取：  
获取jbyteArray java_byte  

```cpp
int byte_len= env->GetArrayLength(java_byte );
char* byte_value=(char*)(env->GetByteArrayElements(java_byte ,0));
//do something
env->ReleaseByteArrayElements(java_byte, (jbyte*)byte_value, 0); 
```
* byte[]返回：  

```cpp
     int byte_len = 10;
     BYTE* byte_value=new BYTE[10]();
     jbyteArray jarrRV = env->NewByteArray(byte_len);
     env->SetByteArrayRegion(jarrRV, 0, byte_len , (jbyte*)byte_value);
     return jarrRV;
```

# 关于java中native方法是否定义为static的问题：

* 定义为static的方法不需要创建该类的实例就能调用，对应生成的.h文件第二个参数是jclass类型，由于不是实例，所以估计（java基础不足只能说估计）如果要在c++上使用这个参数也只能调用到同是static的其他成员变量或者方法
* 非static方法需要先创建该类的实例才可以通过该实例调用，对应.h文件是第二个参数是jobject类型，是调用该方法的实例对象，可以用该变量在c++获取java该对象的其他成员
* 所以，如果修改了java工程中相关定义，记得要根据新生成的.h文件来修改.c/.cpp文件，这个类型一定要对上

